{"ast":null,"code":"import axios from \"axios\";\n\n// API base URL (adjust according to your setup)\nconst API_URL = \"http://localhost:4001\";\n\n// Send the conversation history to the backend and get the chatbot's response\nexport const sendMessageToChatbot = async messages => {\n  try {\n    const response = await axios.post(`${API_URL}/chat`, {\n      messages\n    });\n    return response.data.response;\n  } catch (error) {\n    console.error(\"Error sending message to chatbot:\", error);\n    throw error;\n  }\n};\n\n// Analyze mood based on conversation text\n// export const analyzeMood = async (userInput) => {\n//   try {\n//     const response = await axios.post(`${API_URL}/analyze-mood`, { userInput });\n//     return response.data.mood;\n//   } catch (error) {\n//     console.error(\"Error analyzing mood:\", error);\n//     throw error;\n//   }\n// };\n\napp.post(\"/analyze-mood\", async (req, res) => {\n  try {\n    const {\n      userInput\n    } = req.body;\n    if (!userInput) {\n      return res.status(400).json({\n        error: \"User input is required\"\n      });\n    }\n    const prompt = `\n      You are an expert mood analyst. Based on the following text, classify the overall mood of the entire conversation as one of: Happy, Sad, Angry, Excited, Anxious, or Neutral. Consider the tone, words, and context of the whole input. Return only a single mood value (e.g., \"Sad\") without any additional labels like \"User 1\" or \"User 2\".\n      Here is the text to analyze:\\n\\n${userInput}\n    `;\n    const response = await axios.post(\"https://api.openai.com/v1/chat/completions\", {\n      model: \"gpt-3.5-turbo\",\n      messages: [{\n        role: \"user\",\n        content: prompt\n      }]\n    }, {\n      headers: {\n        Authorization: `Bearer ${OPENAI_API_KEY}`,\n        \"Content-Type\": \"application/json\"\n      }\n    });\n    const mood = response.data.choices[0].message.content.trim();\n    res.json({\n      mood\n    });\n  } catch (error) {\n    var _error$response;\n    console.error(\"Mood analysis error:\", ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data) || error.message);\n    res.status(500).json({\n      error: \"Failed to analyze mood\"\n    });\n  }\n});\n\n// Save the diary entry to localStorage\nexport const saveDiaryEntry = (date, diaryEntry) => {\n  try {\n    const existingData = JSON.parse(localStorage.getItem(date) || '{}');\n    const updatedData = {\n      ...existingData,\n      ...diaryEntry\n    };\n    localStorage.setItem(date, JSON.stringify(updatedData));\n  } catch (error) {\n    console.error(\"Error saving diary entry:\", error);\n  }\n};\n\n// Fetch diary entry for a specific date from localStorage\n// export const getDiaryEntryForDate = (date) => {\n//   try {\n//     const entry = JSON.parse(localStorage.getItem(date) || '{}');\n//     return Object.keys(entry).length > 0 ? entry : null;\n//   } catch (error) {\n//     console.error(\"Error fetching diary entry for date:\", error);\n//     return null;\n//   }\n// };\n\nexport const analyzeSleepAndHealth = async messages => {\n  try {\n    const response = await axios.post(`${API_URL}/analyze-sleep-health`, {\n      messages\n    });\n    return response.data; // { sleepTime: number|null, physicalHealth: \"good\"|\"mid\"|\"bad\"|null }\n  } catch (error) {\n    console.error(\"Error analyzing sleep and health:\", error);\n    return {\n      sleepTime: null,\n      physicalHealth: null\n    };\n  }\n};\nexport const getDiaryEntryForDate = date => {\n  try {\n    // Retrieve the entry for the given date from localStorage\n    const entry = localStorage.getItem(date);\n\n    // If the key doesn't exist or is empty, return null\n    if (!entry) {\n      console.log(\"No diary entry found for this date.\");\n      return null;\n    }\n\n    // Parse the entry data\n    const parsedEntry = JSON.parse(entry);\n\n    // Return only the \"diary\" field, or null if it's not present\n    return parsedEntry;\n  } catch (error) {\n    console.error(\"Error fetching diary entry for date:\", error);\n    return null;\n  }\n};\n// Fetch all diary entries from localStorage\nexport const fetchDiaryEntries = () => {\n  try {\n    const entries = {};\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key.match(/^\\d{4}-\\d{2}-\\d{2}$/)) {\n        // Check if key is a date\n        entries[key] = JSON.parse(localStorage.getItem(key));\n      }\n    }\n    return entries;\n  } catch (error) {\n    console.error(\"Error fetching all diary entries:\", error);\n    return {};\n  }\n};\nexport const transcribeAudio = async audioUrl => {\n  try {\n    const response = await axios.post(`${API_URL}/transcribe`, {\n      audioUrl\n    });\n    return response.data.text;\n  } catch (error) {\n    console.error(\"Error transcribing audio:\", error);\n    throw error;\n  }\n};","map":{"version":3,"names":["axios","API_URL","sendMessageToChatbot","messages","response","post","data","error","console","app","req","res","userInput","body","status","json","prompt","model","role","content","headers","Authorization","OPENAI_API_KEY","mood","choices","message","trim","_error$response","saveDiaryEntry","date","diaryEntry","existingData","JSON","parse","localStorage","getItem","updatedData","setItem","stringify","analyzeSleepAndHealth","sleepTime","physicalHealth","getDiaryEntryForDate","entry","log","parsedEntry","fetchDiaryEntries","entries","i","length","key","match","transcribeAudio","audioUrl","text"],"sources":["/Users/candicechen/Documents/GitHub/journal-app/frontend/src/utils/api.js"],"sourcesContent":["import axios from \"axios\";\n\n// API base URL (adjust according to your setup)\nconst API_URL = \"http://localhost:4001\";\n\n// Send the conversation history to the backend and get the chatbot's response\nexport const sendMessageToChatbot = async (messages) => {\n  try {\n    const response = await axios.post(`${API_URL}/chat`, { messages });\n    return response.data.response;\n  } catch (error) {\n    console.error(\"Error sending message to chatbot:\", error);\n    throw error;\n  }\n};\n\n// Analyze mood based on conversation text\n// export const analyzeMood = async (userInput) => {\n//   try {\n//     const response = await axios.post(`${API_URL}/analyze-mood`, { userInput });\n//     return response.data.mood;\n//   } catch (error) {\n//     console.error(\"Error analyzing mood:\", error);\n//     throw error;\n//   }\n// };\n\napp.post(\"/analyze-mood\", async (req, res) => {\n  try {\n    const { userInput } = req.body;\n\n    if (!userInput) {\n      return res.status(400).json({ error: \"User input is required\" });\n    }\n\n    const prompt = `\n      You are an expert mood analyst. Based on the following text, classify the overall mood of the entire conversation as one of: Happy, Sad, Angry, Excited, Anxious, or Neutral. Consider the tone, words, and context of the whole input. Return only a single mood value (e.g., \"Sad\") without any additional labels like \"User 1\" or \"User 2\".\n      Here is the text to analyze:\\n\\n${userInput}\n    `;\n\n    const response = await axios.post(\n      \"https://api.openai.com/v1/chat/completions\",\n      {\n        model: \"gpt-3.5-turbo\",\n        messages: [{ role: \"user\", content: prompt }],\n      },\n      { headers: { Authorization: `Bearer ${OPENAI_API_KEY}`, \"Content-Type\": \"application/json\" } }\n    );\n\n    const mood = response.data.choices[0].message.content.trim();\n    res.json({ mood });\n  } catch (error) {\n    console.error(\"Mood analysis error:\", error.response?.data || error.message);\n    res.status(500).json({ error: \"Failed to analyze mood\" });\n  }\n});\n\n// Save the diary entry to localStorage\nexport const saveDiaryEntry = (date, diaryEntry) => {\n  try {\n    const existingData = JSON.parse(localStorage.getItem(date) || '{}');\n    const updatedData = { ...existingData, ...diaryEntry };\n    localStorage.setItem(date, JSON.stringify(updatedData));\n  } catch (error) {\n    console.error(\"Error saving diary entry:\", error);\n  }\n};\n\n// Fetch diary entry for a specific date from localStorage\n// export const getDiaryEntryForDate = (date) => {\n//   try {\n//     const entry = JSON.parse(localStorage.getItem(date) || '{}');\n//     return Object.keys(entry).length > 0 ? entry : null;\n//   } catch (error) {\n//     console.error(\"Error fetching diary entry for date:\", error);\n//     return null;\n//   }\n// };\n\nexport const analyzeSleepAndHealth = async (messages) => {\n  try {\n    const response = await axios.post(`${API_URL}/analyze-sleep-health`, { messages });\n    return response.data; // { sleepTime: number|null, physicalHealth: \"good\"|\"mid\"|\"bad\"|null }\n  } catch (error) {\n    console.error(\"Error analyzing sleep and health:\", error);\n    return { sleepTime: null, physicalHealth: null };\n  }\n};\n\nexport const getDiaryEntryForDate = (date) => {\n  try {\n    // Retrieve the entry for the given date from localStorage\n    const entry = localStorage.getItem(date);\n\n    // If the key doesn't exist or is empty, return null\n    if (!entry) {\n      console.log(\"No diary entry found for this date.\");\n      return null;\n    }\n\n    // Parse the entry data\n    const parsedEntry = JSON.parse(entry);\n\n    // Return only the \"diary\" field, or null if it's not present\n    return parsedEntry;\n\n  } catch (error) {\n    console.error(\"Error fetching diary entry for date:\", error);\n    return null;\n  }\n};\n// Fetch all diary entries from localStorage\nexport const fetchDiaryEntries = () => {\n  try {\n    const entries = {};\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key.match(/^\\d{4}-\\d{2}-\\d{2}$/)) { // Check if key is a date\n        entries[key] = JSON.parse(localStorage.getItem(key));\n      }\n    }\n    return entries;\n  } catch (error) {\n    console.error(\"Error fetching all diary entries:\", error);\n    return {};\n  }\n};\n\nexport const transcribeAudio = async (audioUrl) => {\n  try {\n    const response = await axios.post(`${API_URL}/transcribe`, { audioUrl });\n    return response.data.text;\n  } catch (error) {\n    console.error(\"Error transcribing audio:\", error);\n    throw error;\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}